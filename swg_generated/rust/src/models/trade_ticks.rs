/* 
 * Upbit Open API
 *
 * ## REST API for Upbit Exchange - Base URL: [https://api.upbit.com] - Official Upbit API Documents: [https://docs.upbit.com] - Official Support email: [open-api@upbit.com] 
 *
 * OpenAPI spec version: 1.0.0
 * Contact: ujhin942@gmail.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct TradeTicks {
  /// 마켓 구분 코드
  #[serde(rename = "market")]
  market: Option<String>,
  /// 체결 일자 (UTC 기준)
  #[serde(rename = "trade_date_utc")]
  trade_date_utc: Option<String>,
  /// 체결 시각 (UTC 기준)
  #[serde(rename = "trade_time_utc")]
  trade_time_utc: Option<String>,
  /// 체결 타임스탬프
  #[serde(rename = "timestamp")]
  timestamp: Option<f32>,
  /// 체결 가격
  #[serde(rename = "trade_price")]
  trade_price: Option<f64>,
  /// 체결량
  #[serde(rename = "trade_volume")]
  trade_volume: Option<f64>,
  /// 전일 종가
  #[serde(rename = "prev_closing_price")]
  prev_closing_price: Option<f64>,
  /// 변화량
  #[serde(rename = "change_price")]
  change_price: Option<f64>,
  /// 매도/매수
  #[serde(rename = "ask_bid")]
  ask_bid: Option<String>,
  /// 체결 번호 (Unique) `sequential_id` 필드는 체결의 유일성 판단을 위한 근거로 쓰일 수 있습니다. 하지만 체결의 순서를 보장하지는 못합니다. 
  #[serde(rename = "sequential_id")]
  sequential_id: Option<f32>
}

impl TradeTicks {
  pub fn new() -> TradeTicks {
    TradeTicks {
      market: None,
      trade_date_utc: None,
      trade_time_utc: None,
      timestamp: None,
      trade_price: None,
      trade_volume: None,
      prev_closing_price: None,
      change_price: None,
      ask_bid: None,
      sequential_id: None
    }
  }

  pub fn set_market(&mut self, market: String) {
    self.market = Some(market);
  }

  pub fn with_market(mut self, market: String) -> TradeTicks {
    self.market = Some(market);
    self
  }

  pub fn market(&self) -> Option<&String> {
    self.market.as_ref()
  }

  pub fn reset_market(&mut self) {
    self.market = None;
  }

  pub fn set_trade_date_utc(&mut self, trade_date_utc: String) {
    self.trade_date_utc = Some(trade_date_utc);
  }

  pub fn with_trade_date_utc(mut self, trade_date_utc: String) -> TradeTicks {
    self.trade_date_utc = Some(trade_date_utc);
    self
  }

  pub fn trade_date_utc(&self) -> Option<&String> {
    self.trade_date_utc.as_ref()
  }

  pub fn reset_trade_date_utc(&mut self) {
    self.trade_date_utc = None;
  }

  pub fn set_trade_time_utc(&mut self, trade_time_utc: String) {
    self.trade_time_utc = Some(trade_time_utc);
  }

  pub fn with_trade_time_utc(mut self, trade_time_utc: String) -> TradeTicks {
    self.trade_time_utc = Some(trade_time_utc);
    self
  }

  pub fn trade_time_utc(&self) -> Option<&String> {
    self.trade_time_utc.as_ref()
  }

  pub fn reset_trade_time_utc(&mut self) {
    self.trade_time_utc = None;
  }

  pub fn set_timestamp(&mut self, timestamp: f32) {
    self.timestamp = Some(timestamp);
  }

  pub fn with_timestamp(mut self, timestamp: f32) -> TradeTicks {
    self.timestamp = Some(timestamp);
    self
  }

  pub fn timestamp(&self) -> Option<&f32> {
    self.timestamp.as_ref()
  }

  pub fn reset_timestamp(&mut self) {
    self.timestamp = None;
  }

  pub fn set_trade_price(&mut self, trade_price: f64) {
    self.trade_price = Some(trade_price);
  }

  pub fn with_trade_price(mut self, trade_price: f64) -> TradeTicks {
    self.trade_price = Some(trade_price);
    self
  }

  pub fn trade_price(&self) -> Option<&f64> {
    self.trade_price.as_ref()
  }

  pub fn reset_trade_price(&mut self) {
    self.trade_price = None;
  }

  pub fn set_trade_volume(&mut self, trade_volume: f64) {
    self.trade_volume = Some(trade_volume);
  }

  pub fn with_trade_volume(mut self, trade_volume: f64) -> TradeTicks {
    self.trade_volume = Some(trade_volume);
    self
  }

  pub fn trade_volume(&self) -> Option<&f64> {
    self.trade_volume.as_ref()
  }

  pub fn reset_trade_volume(&mut self) {
    self.trade_volume = None;
  }

  pub fn set_prev_closing_price(&mut self, prev_closing_price: f64) {
    self.prev_closing_price = Some(prev_closing_price);
  }

  pub fn with_prev_closing_price(mut self, prev_closing_price: f64) -> TradeTicks {
    self.prev_closing_price = Some(prev_closing_price);
    self
  }

  pub fn prev_closing_price(&self) -> Option<&f64> {
    self.prev_closing_price.as_ref()
  }

  pub fn reset_prev_closing_price(&mut self) {
    self.prev_closing_price = None;
  }

  pub fn set_change_price(&mut self, change_price: f64) {
    self.change_price = Some(change_price);
  }

  pub fn with_change_price(mut self, change_price: f64) -> TradeTicks {
    self.change_price = Some(change_price);
    self
  }

  pub fn change_price(&self) -> Option<&f64> {
    self.change_price.as_ref()
  }

  pub fn reset_change_price(&mut self) {
    self.change_price = None;
  }

  pub fn set_ask_bid(&mut self, ask_bid: String) {
    self.ask_bid = Some(ask_bid);
  }

  pub fn with_ask_bid(mut self, ask_bid: String) -> TradeTicks {
    self.ask_bid = Some(ask_bid);
    self
  }

  pub fn ask_bid(&self) -> Option<&String> {
    self.ask_bid.as_ref()
  }

  pub fn reset_ask_bid(&mut self) {
    self.ask_bid = None;
  }

  pub fn set_sequential_id(&mut self, sequential_id: f32) {
    self.sequential_id = Some(sequential_id);
  }

  pub fn with_sequential_id(mut self, sequential_id: f32) -> TradeTicks {
    self.sequential_id = Some(sequential_id);
    self
  }

  pub fn sequential_id(&self) -> Option<&f32> {
    self.sequential_id.as_ref()
  }

  pub fn reset_sequential_id(&mut self) {
    self.sequential_id = None;
  }

}



